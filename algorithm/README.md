## Algorithm
### BFS
- Queue
- 1. 최소비용
- 2. 간선의 가중치 1
- 3. 정점과 간선의 개수가 적다.(시간 제약, 메모리 제한 내에 만족한다.)
- BFS는 모든 분기점을 다 검사하면서 진행하는 방식. EX) 철수와 영희가 계단에서 가위바위보를 할 때, 철수가 원하는 지점에 갈 수 있는 최소 승리 횟수는 얼마인가?
- BFS는 모든 분기를 다 검색하면서 상태공간을 탐색. 철수가 이겼을 때, 비겼을 때, 졌을 때를 검사하고, 그 경우마다 각각 또다른 3가지 가능성을 전부 검사하다가  어느 한 부분에서 원하는 해를 발견하면, 이것이 최단 거리가 된다. 그러나  이 경우 DFS는 깊이가 무한인 경우에 빠져나오지 못하며, 중복 방지를 한다고 치더라도 올바른 해를 찾는데 시간이 많이 걸림 
- 각 경우를 검사하면서 발생하는 새로운 경우를 큐에 집어넣고, 검사한 원소는 큐에서 뺀다. **BFS의 장점**은 DFS가 못 건드리는 문제를 풀 수 있는 것이지만, 공간 복잡도가 지수 급으로로 증가하기 때문에 제대로 안짜면 DFS보다 빨리 오버플로우 발생함

### DFS
- Stack, Recursion
- DFS는 상태공간을 나타낸 트리에서 바닥에 도달할 때까지 한 쪽 방향으로만 내려가는 방식. EX) 미로찾기 
- 한 방향으로 들어갔다가 막다른 길에 다다르면(=트리의 바닥에 도착) 왔던 길을 돌아가서 다른 방향으로 간다. 이 짓을 목표지점(=원하는 해)이 나올 때까지 반복.


### MST
- Kruskal
- Prim

#### Kruskal
탐욕적인 방법(greedy method) 을 이용하여 네트워크(가중치를 간선에 할당한 그래프)의 모든 정점을 최소 비용으로 연결하는 최적 해답을 구하는 것

#### Prim
시작 정점에서부터 출발하여 신장트리 집합을 단계적으로 확장 해나가는 방법

#### Segment Tree
- 대표값을 트리형태로 저장하는 자료구조
- 각 노드는 자식 노드들을 대표하는 값을 가짐  
![1](https://user-images.githubusercontent.com/32935365/63648002-403e6a00-c764-11e9-87cb-e485ad5d577b.PNG)

#### Lazy Propagation
- 게으르게 업데이트를 전파시켜서 O( logN )만에 Segment Tree에서 구간 업데이트를 달성하는 알고리즘

#### Back Tracking
- Stack
- 모든 경우의 수를 전부 고려하는 알고리즘. 상태공간을 트리로 나타낼 수 있을 때 적합한 방식
- 해답이 되는 길을 stack에 저장
- DFS, BFS 등의 사용

#### Trie
- 문자열 검색을 빠르게 해주는 자료구조로 K진 트리 형태
- 주로 스트링을 가지는 동적 셋 혹은 연관 배열을 저장하는데 사용되는 정렬된 트리 자료구조
- 이진 검색 트리와는 다르게, 트리상에서의 노드들은 그 노드와 연관된 키를 저장하지 않음.
- 트리상에서의 위치가 현재의 키를 나타낸다. 특정 노드의 모든 후손들은 그 노드에서와 동일한 prefix를 가지며, 루트 노드는 빈 문자열을 갖는다.
- 값은 모든 노드에서 존재하는 것이 아니고, 말단 노드(leaves) 혹은 특정 키에 해당하는 내부(inner) 노드에서만 존재한다.  
![1](https://user-images.githubusercontent.com/32935365/64130050-cc066500-cdfa-11e9-9847-edad9d4c458f.PNG)

