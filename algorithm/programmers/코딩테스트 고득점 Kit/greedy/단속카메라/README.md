### 문제

https://school.programmers.co.kr/learn/courses/30/lessons/42884

### 1\. 문제 분석: 무엇을 기준으로 선택할 것인가?

문제의 목표는 **최소한의 카메라**를 설치하여 모든 차량의 경로를 한 번 이상 지나가도록 하는 것입니다. 즉, 모든 구간(`[진입, 진출]`)에 최소한의 점(카메라)을 찍는 문제입니다.

이 문제를 해결하기 위해 어떤 탐욕적인(Greedy) 선택을 해야 할지 고민해야 합니다.

  * 차량이 진입한 지점을 기준으로 정렬하고 카메라를 설치할까?
  * 아니면 차량이 나간 지점을 기준으로 정렬할까?

만약 진입 지점 기준으로 정렬한다면, 카메라를 어디에 설치하는 것이 최적일지 판단하기가 애매합니다. 빨리 진입한 차량의 경로 내에 카메라를 설치해도, 늦게 진입하는 차량을 놓칠 수 있기 때문입니다.

하지만 **진출(종료) 지점**을 기준으로 생각하면 명확한 전략을 세울 수 있습니다.

-----

### 2\. 핵심 아이디어: 종료 지점을 기준으로 정렬하라

이 문제의 핵심은 **모든 차량의 경로를 차량이 고속도로를 나간 지점(종료 지점) 기준으로 오름차순 정렬**하는 것입니다.

왜 종료 지점일까요?

> **가장 빨리 고속도로를 나가는 차량**은 반드시 카메라에 찍혀야 합니다. 이 차량을 찍기 위한 카메라는 이 차량의 `[진입, 진출]` 구간 내 어딘가에 설치되어야 합니다.

이때, 카메라를 어디에 설치하는 것이 가장 이득일까요? 바로 **해당 차량의 진출 지점**에 설치하는 것입니다.

진출 지점에 카메라를 설치하면, 그 지점을 지나가는 다른 차량들도 함께 단속할 수 있는 가능성이 극대화됩니다. 즉, 카메라를 가능한 한 뒤쪽(오른쪽)으로 밀어서, 더 많은 차량의 경로와 겹치게 만드는 전략입니다.

-----

### 3\. 그리디 알고리즘 설계

위 아이디어를 바탕으로 알고리즘을 설계하면 다음과 같습니다.

1.  모든 차량의 경로(`routes`)를 **진출 지점(`routes[i][1]`)을 기준으로 오름차순 정렬**합니다.
2.  첫 번째 카메라를 설치합니다. 카메라의 위치는 정렬된 첫 번째 차량의 **진출 지점**입니다. (`카메라 개수 = 1`)
3.  정렬된 두 번째 차량부터 마지막 차량까지 순서대로 확인합니다.
      * 현재 차량의 **진입 지점**이 이전에 설치한 **카메라의 위치보다 뒤에 있다면**, 이 차량은 이전 카메라에 단속되지 않은 것입니다.
          * `if (현재 차량의 진입 지점 > 마지막 카메라 위치)`
      * 이 경우, 새로운 카메라가 필요합니다. 새로운 카메라를 **현재 차량의 진출 지점**에 설치하고 `카메라 개수`를 1 증가시킵니다.
      * 만약 현재 차량의 경로가 이전 카메라 위치를 포함한다면, 이미 단속되었으므로 그냥 넘어갑니다.
4.  모든 차량을 확인할 때까지 반복하면, 최종 `카메라 개수`가 최소 설치 대수가 됩니다.

-----

### 4\. Java 코드 구현

```java
import java.util.Arrays;
import java.util.Comparator;

class Solution {
    public int solution(int[][] routes) {
        // 1. 차량 경로를 진출 지점 기준으로 오름차순 정렬
        Arrays.sort(routes, Comparator.comparingInt(route -> route[1]));
        
        int cameraCount = 0;
        int lastCameraPosition = -30001; // 카메라 위치 초기화 (문제의 최소 범위보다 작게)

        // 2. 정렬된 경로를 순회
        for (int[] route : routes) {
            // 3. 현재 차량의 진입 지점이 마지막 카메라 위치보다 뒤에 있는 경우
            // 즉, 현재 카메라로는 이 차량을 단속할 수 없는 경우
            if (route[0] > lastCameraPosition) {
                // 4. 새로운 카메라를 현재 차량의 진출 지점에 설치
                cameraCount++;
                lastCameraPosition = route[1];
            }
        }
        
        return cameraCount;
    }
}
```

-----

### 5\. 시간 복잡도 및 공간 복잡도 분석

  * **시간 복잡도: $O(N \log N)$**

      * `N`은 차량의 대수(`routes`의 길이)입니다.
      * `Arrays.sort()`를 수행하는 데 $O(N \log N)$의 시간이 걸립니다.
      * 이후 `for` 루프는 `N`번 순회하므로 $O(N)$이 걸립니다.
      * 따라서 전체 시간 복잡도는 정렬에 의해 결정됩니다.

  * **공간 복잡도: $O(\log N)$ 또는 $O(N)$**

      * Java의 `Arrays.sort()`는 내부적으로 TimSort를 사용하며, 이는 최악의 경우 $O(N)$의 추가 공간을 사용할 수 있습니다. (일반적으로는 $O(\log N)$) 코딩 테스트 환경에서는 보통 정렬에 필요한 공간은 별도로 크게 고려하지 않아도 무방합니다.

-----

### 6\. 추가적으로 연관된 내용 및 꼬리질문

#### Q1: 왜 진입 지점(start)이 아닌 진출 지점(end)으로 정렬하는 것이 더 효과적인가요?

진입 지점으로 정렬하고 카메라를 진입 지점에 설치하면, 해당 카메라가 너무 일찍 설치되어 뒤따라오는 많은 차량의 경로와 겹치지 않을 수 있습니다. 반면, 진출 지점으로 정렬하고 카메라를 **진출 지점**에 설치하면, 해당 차량을 단속할 수 있는 가장 마지막 위치에 카메라를 두는 셈이 됩니다. 이로 인해 해당 카메라가 다른 차량들의 경로와 겹칠 확률이 최대화되어 더 효율적인 선택이 됩니다.

#### Q2: 이 그리디 접근법이 항상 최적의 해를 보장하는 이유는 무엇인가요?

가장 먼저 끝나는 경로 `A`를 생각해보겠습니다. 이 경로 `A`는 반드시 카메라에 포함되어야 합니다. 이때 카메라를 `A`의 종료 지점에 설치하면, `A`를 포함하는 다른 모든 경로들도 이 카메라에 단속될 가능성이 생깁니다. 이 선택은 남은 문제(아직 단속되지 않은 차량들)의 규모를 전혀 해치지 않으면서 현재 상황에서 최선의 선택을 하는 것입니다. 이러한 "매 순간의 최적해가 전체의 최적해로 이어진다"는 그리디 선택 속성(Greedy Choice Property)이 성립하기 때문에 정당합니다.

#### Q3: 이와 비슷한 유형의 다른 문제는 어떤 것이 있나요?

이 문제는 '겹치는 구간'을 다루는 대표적인 그리디 문제입니다. 비슷한 유형으로는 다음과 같은 문제들이 있습니다.

  * **회의실 배정 문제**: 한정된 회의실에 가장 많은 회의를 배정하는 문제. (종료 시간 기준 정렬)
  * **최대 구간 겹침 문제**: 가장 많은 구간이 겹치는 지점을 찾는 문제.