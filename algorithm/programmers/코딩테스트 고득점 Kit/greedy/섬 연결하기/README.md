## 문제

https://school.programmers.co.kr/learn/courses/30/lessons/42861

### 1\. 문제 분석: 최소 신장 트리 (MST)란?

이 문제는 그래프 이론의 관점에서 볼 수 있습니다.

  * **섬(Island)**: 그래프의 **정점(Vertex)**
  * **다리 건설 비용(Cost)**: 두 정점을 잇는 **간선(Edge)의 가중치(Weight)**

우리의 목표는 모든 섬을 연결하되, 그 비용의 합이 최소가 되도록 하는 것입니다. 이는 그래프의 모든 정점을 포함하면서 사이클이 없는 **신장 트리(Spanning Tree)** 중에서, 간선 가중치의 합이 가장 작은 \*\*최소 신장 트리(MST)\*\*를 찾는 것과 같습니다.

MST를 찾는 대표적인 알고리즘으로는 \*\*크루스칼(Kruskal)\*\*과 \*\*프림(Prim)\*\*이 있습니다. 이 문제의 경우, 간선(costs) 리스트가 주어지므로 크루스칼 알고리즘을 적용하는 것이 더 직관적이고 편리합니다.

-----

### 2\. 핵심 알고리즘: 크루스칼 (Kruskal) 알고리즘

크루스칼 알고리즘은 \*\*탐욕법(Greedy Algorithm)\*\*에 기반합니다. 가장 비용이 적게 드는 선택을 계속해서 해나가는 방식입니다.

**알고리즘 동작 방식:**

1.  모든 다리(간선)를 건설 비용(가중치)에 따라 **오름차순으로 정렬**합니다.
2.  가장 비용이 적은 다리부터 순서대로 확인하면서, 해당 다리를 추가했을 때 **사이클(Cycle)이 형성되는지 확인**합니다.
      * **사이클이 형성되지 않으면:** 해당 다리를 채택하고, 건설 비용을 총비용에 더합니다.
      * **사이클이 형성되면:** 해당 다리는 무시하고 다음으로 넘어갑니다. (이미 다른 경로로 연결되어 있다는 의미)
3.  총 `n-1`개의 다리가 선택될 때까지 이 과정을 반복합니다. (n개의 섬을 연결하는 데 필요한 최소 다리 수는 `n-1`개입니다.)

여기서 가장 중요한 질문은 "어떻게 다리를 추가할 때 사이클이 생기는지 효율적으로 판별할 것인가?" 입니다. 바로 이 지점에서 **Union-Find** 자료구조가 사용됩니다.

-----

### 3\. 사이클 판별을 위한 Union-Find 자료구조

Union-Find(또는 Disjoint Set)는 "서로소 집합"을 관리하는 자료구조입니다. 각 섬이 처음에는 자신만의 독립적인 집합(팀)에 속해있다고 생각하면 쉽습니다.

  * **`find(x)` 연산**: 섬 `x`가 현재 어떤 집합(팀)에 속해있는지 확인합니다. (팀의 대표를 찾아 반환)
  * **`union(x, y)` 연산**: 섬 `x`가 속한 팀과 섬 `y`가 속한 팀을 하나로 합칩니다.

**사이클 판별 원리:**
다리를 놓으려는 두 섬 `A`와 `B`가 있다고 할 때,

  * `find(A)`와 `find(B)`의 결과가 **다르다면**: 두 섬은 아직 다른 경로로 연결되어 있지 않은 상태입니다. (서로 다른 팀 소속) 따라서 다리를 놓아도 사이클이 생기지 않으며, `union(A, B)`를 통해 두 섬의 팀을 합칩니다.
  * `find(A)`와 `find(B)`의 결과가 **같다면**: 두 섬은 이미 다른 다리들을 통해 연결된 상태입니다. (같은 팀 소속) 여기에 다리를 또 놓으면 사이클이 발생하므로, 이 다리는 무시해야 합니다.

-----

### 4\. Java 코드 구현

```java
import java.util.Arrays;
import java.util.Comparator;

class Solution {
    // 각 섬의 부모 노드를 저장할 배열
    private int[] parent;

    // find 연산: x의 루트 노드를 찾음 (경로 압축 최적화 포함)
    private int find(int x) {
        if (parent[x] == x) {
            return x;
        }
        return parent[x] = find(parent[x]);
    }

    // union 연산: y의 루트 노드를 x의 루트 노드에 연결
    private void union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX != rootY) {
            parent[rootY] = rootX;
        }
    }

    public int solution(int n, int[][] costs) {
        int answer = 0;

        // 1. 비용(가중치) 기준으로 간선들을 오름차순 정렬
        Arrays.sort(costs, Comparator.comparingInt(o -> o[2]));

        // 2. Union-Find를 위한 parent 배열 초기화 (각자 자신을 부모로 가짐)
        parent = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }

        // 3. 정렬된 간선을 순회하며 MST 구성
        for (int[] edge : costs) {
            int from = edge[0];
            int to = edge[1];
            int cost = edge[2];

            // 4. 두 노드의 부모가 다를 경우 (사이클이 형성되지 않음)
            if (find(from) != find(to)) {
                union(from, to); // 두 집합을 합침
                answer += cost;  // 비용 추가
            }
        }
        
        return answer;
    }
}
```

-----

### 5\. 시간 복잡도 및 공간 복잡도 분석

  * **시간 복잡도: $O(E \log E)$**

      * `E`는 다리의 개수(`costs`의 길이)입니다.
      * **간선 정렬**: `Arrays.sort()`는 $O(E \log E)$의 시간이 걸립니다.
      * **Union-Find 연산**: 경로 압축과 같은 최적화 기법을 사용하면, `E`개의 간선에 대한 `union`과 `find` 연산은 거의 상수 시간에 가깝습니다 (정확히는 아커만 함수의 역함수인 $O(\alpha(N))$ 이지만, 상수 시간으로 간주해도 무방). 따라서 이 부분은 $O(E)$입니다.
      * 결론적으로 전체 시간 복잡도는 **정렬 시간**이 지배하게 되어 $O(E \log E)$가 됩니다.

  * **공간 복잡도: $O(N)$**

      * `N`은 섬의 개수입니다.
      * Union-Find를 위한 `parent` 배열이 `N`만큼의 공간을 필요로 합니다.

-----

### 6\. 추가적으로 연관된 내용 및 꼬리질문

#### Q1. 프림(Prim) 알고리즘으로는 이 문제를 어떻게 푸나요?

프림 알고리즘은 정점(섬)을 중심으로 확장해나가는 방식입니다.

1.  임의의 섬 하나를 시작점으로 선택하여 MST 집합에 포함시킵니다.
2.  MST 집합에 포함된 섬들과 포함되지 않은 섬들을 잇는 다리 중, 가장 비용이 적은 다리를 선택합니다.
3.  해당 다리와 연결된, 아직 MST에 포함되지 않은 섬을 MST 집합에 추가합니다.
4.  모든 섬이 MST 집합에 포함될 때까지 2-3번 과정을 반복합니다.
    이 과정에서 가장 비용이 적은 다리를 효율적으로 찾기 위해 **우선순위 큐(Priority Queue)** 자료구조가 사용됩니다.

#### Q2. 크루스칼과 프림 알고리즘은 언제 사용하는 것이 좋은가요?

  * **크루스칼**: 지금 문제처럼 \*\*간선의 수가 적은 희소 그래프(Sparse Graph)\*\*에서 유리합니다. 간선 정렬이 핵심이므로 간선 수가 적을수록 빠릅니다.
  * **프림**: \*\*간선의 수가 많은 밀집 그래프(Dense Graph)\*\*에서 유리할 수 있습니다. 우선순위 큐를 사용하며, 정점의 수에 더 큰 영향을 받습니다.

#### Q3. `find` 함수에서 `parent[x] = find(parent[x])`는 무엇을 의미하나요?

이는 \*\*경로 압축(Path Compression)\*\*이라는 Union-Find의 중요한 최적화 기법입니다. `find` 연산을 수행하면서 거쳐 가는 모든 노드가 트리의 최종 루트를 직접 가리키도록 `parent` 배열을 갱신합니다. 이를 통해 트리의 높이가 낮아져, 추후의 `find` 연산 속도가 비약적으로 빨라집니다.