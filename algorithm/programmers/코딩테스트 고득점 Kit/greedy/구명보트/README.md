### 문제

https://school.programmers.co.kr/learn/courses/30/lessons/42885

### 1\. 문제 분석 및 핵심 전략

문제의 목표는 **최소한의 구명보트**를 사용하여 모든 사람을 구출하는 것입니다. 보트에는 최대 2명까지 탈 수 있으므로, 보트 하나를 아끼는 유일한 방법은 2명을 함께 태우는 것입니다.

그렇다면 어떤 두 사람을 짝지어 태우는 것이 가장 효율적일까요?

> **가장 무거운 사람**을 기준으로 생각해봅시다.

가장 무거운 사람은 보트의 무게 제한(`limit`)을 가장 많이 차지합니다. 이 사람과 함께 탈 수 있는 가능성이 있는 사람은 **가장 가벼운 사람**뿐일 것입니다. 만약 가장 가벼운 사람조차 이 사람과 함께 탈 수 없다면, 다른 어떤 사람도 함께 탈 수 없습니다.

이것이 바로 이 문제의 핵심 **그리디 전략**입니다.

  * 항상 **가장 무거운 사람**과 **가장 가벼운 사람**을 짝지어 태우는 것을 시도합니다.
  * 만약 두 사람의 무게 합이 `limit`을 초과하면, 가장 무거운 사람은 어쩔 수 없이 혼자 보트를 타야 합니다.
  * 만약 두 사람의 무게 합이 `limit` 이하라면, 함께 보트를 태워 보트 하나를 아낄 수 있습니다.

이 전략이 최적인 이유는, 가장 무거운 사람을 처리할 때 가장 가벼운 사람을 함께 태워 "소모"시키는 것이 남은 사람들을 처리하는 데 있어 최상의 선택지를 남겨주기 때문입니다.

-----

### 2\. 그리디 알고리즘 설계 (투 포인터)

위의 그리디 전략을 효율적으로 구현하기 위해 **투 포인터** 기법을 사용합니다.

1.  먼저 사람들의 몸무게 배열 `people`을 **오름차순으로 정렬**합니다. 이렇게 하면 배열의 맨 앞에는 가장 가벼운 사람이, 맨 뒤에는 가장 무거운 사람이 위치하게 됩니다.
2.  두 개의 포인터를 준비합니다.
      * `left` 포인터: 가장 가벼운 사람을 가리킴 (배열의 시작, 인덱스 0)
      * `right` 포인터: 가장 무거운 사람을 가리킴 (배열의 끝, 인덱스 `n-1`)
3.  `left` 포인터가 `right` 포인터보다 작거나 같을 때까지 다음을 반복합니다.
      * \*\*가장 무거운 사람(`people[right]`)\*\*과 \*\*가장 가벼운 사람(`people[left]`)\*\*의 무게 합을 `limit`과 비교합니다.
      * **`if (people[left] + people[right] <= limit)`**: 두 사람을 함께 태울 수 있습니다. 이 경우, 두 사람 모두 구출되었으므로 `left` 포인터를 한 칸 오른쪽으로, `right` 포인터를 한 칸 왼쪽으로 이동시킵니다.
      * **`else`**: 두 사람을 함께 태울 수 없습니다. 가장 무거운 사람은 혼자 타야만 합니다. 따라서 `right` 포인터만 한 칸 왼쪽으로 이동시킵니다. (가장 가벼운 사람은 다음 차례를 기다립니다.)
4.  위의 `if` 또는 `else` 로직이 한 번 실행될 때마다, 보트가 한 대 사용된 것입니다. 따라서 반복문이 돌 때마다 보트의 개수(`answer`)를 1씩 증가시킵니다.
5.  `left`가 `right`를 넘어서면 모든 사람을 확인한 것이므로 반복을 종료합니다.

-----

### 3\. Java 코드 구현

```java
import java.util.Arrays;

class Solution {
    public int solution(int[] people, int limit) {
        int answer = 0;
        
        // 1. 사람들의 몸무게를 오름차순으로 정렬
        Arrays.sort(people);
        
        // 2. 투 포인터 초기화
        int left = 0; // 가장 가벼운 사람의 인덱스
        int right = people.length - 1; // 가장 무거운 사람의 인덱스
        
        while (left <= right) {
            // 3. 가장 무거운 사람과 가장 가벼운 사람의 무게를 합쳐서 limit과 비교
            if (people[left] + people[right] <= limit) {
                // 함께 탈 수 있는 경우, 두 사람 모두 구출 처리
                left++;
                right--;
            } else {
                // 함께 탈 수 없는 경우, 가장 무거운 사람만 구출 처리
                right--;
            }
            // 어떤 경우든 보트는 한 대 사용됨 => 여기가 포인트. 어쨋든 한대가 출발했다.
            answer++;
        }
        
        return answer;
    }
}
```

-----

### 4\. 시간 복잡도 및 공간 복잡도 분석

  * **시간 복잡도: $O(N \log N)$**

      * `N`은 사람의 수(`people` 배열의 길이)입니다.
      * `Arrays.sort(people)`를 수행하는 데 $O(N \log N)$의 시간이 걸립니다.
      * 이후 투 포인터를 이용한 `while` 루프는 배열을 한 번만 순회하므로 $O(N)$이 걸립니다.
      * 따라서 전체 시간 복잡도는 정렬에 의해 결정됩니다.

  * **공간 복잡도: $O(1)$ 또는 $O(\log N)$**

      * 별도의 자료구조를 사용하지 않았습니다.
      * Java의 `Arrays.sort()`는 Dual-Pivot Quicksort를 사용하므로 평균적으로 $O(\log N)$의 스택 공간을 사용합니다. 이를 고려하면 공간 복잡도는 $O(\log N)$이 됩니다. (코딩 테스트에서는 일반적으로 $O(1)$로 간주해도 무방합니다.)

-----

### 5\. 추가적으로 연관된 내용 및 꼬리질문

#### Q1. 왜 반드시 정렬을 해야 하나요?

이 문제의 핵심인 그리디 전략, 즉 "가장 무거운 사람과 가장 가벼운 사람을 짝짓는다"를 효율적으로 수행하기 위해서입니다. 정렬을 하지 않으면 매번 배열 전체를 탐색하여 최댓값과 최솟값을 찾아야 하므로 시간 복잡도가 $O(N^2)$으로 비효율적이게 됩니다. 정렬을 통해 $O(1)$의 시간으로 양 끝의 값에 접근할 수 있습니다.

#### Q2. `while (left < right)`가 아닌 `while (left <= right)`를 사용하는 이유는 무엇인가요?

만약 마지막에 한 사람만 남게 되면 `left`와 `right`가 같은 인덱스를 가리키게 됩니다. 이 사람도 구출해야 하므로 보트 한 대가 필요합니다. `left <= right` 조건은 이 마지막 한 명의 경우까지 처리하기 위함입니다. 만약 `left < right`로 하면 마지막 한 명이 남았을 때 루프가 종료되어 그 사람을 구출하는 `answer++`가 실행되지 않습니다.

#### Q3. 이 그리디 접근법이 항상 최적의 해를 보장하는 이유는 무엇인가요?

가장 무거운 사람 `H`와 가장 가벼운 사람 `L`이 있다고 가정해봅시다.

1.  **`H`와 `L`을 함께 태우는 경우**: 이렇게 함으로써 우리는 보트 하나를 아낄 수 있는 최고의 기회를 사용한 것입니다. `H`와 다른 사람을 태우는 것보다 `H`와 `L`을 태우는 것이 남은 사람들에게 더 유리한 상황을 만들어줍니다.
2.  **`H`와 `L`을 함께 태울 수 없는 경우**: 이때 `H`는 다른 누구와도 탈 수 없으므로 반드시 혼자 타야 합니다. `H`를 혼자 태우는 것이 최적의 선택이며, 이는 `L`을 다른 사람과 짝지을 수 있는 기회로 남겨두는 것이기 때문입니다.
    이처럼 매 순간의 선택이 이후의 선택에 나쁜 영향을 주지 않고 최적의 결과를 이끌어내므로, 이 그리디 해법은 정당합니다.