## 문제

https://school.programmers.co.kr/learn/courses/30/lessons/42883

-----

### 1\. 문제 분석: 단순한 조합의 한계

가장 먼저 생각할 수 있는 방법은 `number`의 숫자들 중 `k`개를 제거하는 모든 조합을 만들어보고, 그중 가장 큰 값을 찾는 것입니다. 하지만 `number`의 길이가 최대 1,000,000에 달하므로, 조합의 수는 기하급수적으로 늘어나 시간 내에 절대 해결할 수 없습니다.

따라서 우리는 더 효율적인 방법, 즉 매 순간 최선의 선택을 하는 **그리디 알고리즘**을 사용해야 합니다. 가장 큰 수를 만든다는 것은, 결과적으로 만들어질 숫자의 **앞자리부터 가장 큰 숫자로 채워야 한다**는 의미입니다.

-----

### 2\. 핵심 아이디어: 스택을 이용한 그리디 전략

결과로 만들어질 숫자를 왼쪽부터 차곡차곡 쌓아나간다고 상상해 봅시다. 이때 **스택(Stack)** 자료구조가 이 과정을 구현하기에 안성맞춤입니다.

알고리즘의 핵심 아이디어는 다음과 같습니다.

> 숫자를 앞에서부터 하나씩 순회하면서, 스택에 쌓여있는 마지막 숫자보다 현재 숫자가 더 크다면, 스택의 마지막 숫자를 제거하고 현재 숫자를 넣습니다. 이 과정을 제거할 수 있는 횟수(`k`)가 남아있는 동안 반복합니다.

이렇게 하면 스택에는 항상 **가장 큰 수가 될 가능성이 있는 숫자들**이 앞에서부터 순서대로 남게 됩니다.

-----

### 3\. 알고리즘 설계 및 단계별 예시

**알고리즘 설계:**

1.  결과를 저장할 스택(또는 `StringBuilder`)을 준비합니다.
2.  입력받은 숫자 문자열(`number`)을 첫 번째 자릿수부터 순서대로 순회합니다.
3.  현재 확인하는 숫자(`current_digit`)에 대해 다음을 반복합니다.
      * **`while`** (스택이 비어있지 않고) **`&&`** (제거 횟수 `k`가 0보다 크고) **`&&`** (스택의 마지막 숫자가 `current_digit`보다 작으면):
          * 스택의 마지막 숫자를 제거(pop)합니다.
          * 제거 횟수 `k`를 1 감소시킵니다.
4.  `while` 루프가 끝나면, `current_digit`을 스택에 추가(push)합니다.
5.  모든 숫자를 순회한 후에도 `k`가 남아있다면 (예: "98765"처럼 내림차순인 경우), 스택의 뒤에서부터 `k`개만큼 숫자를 제거합니다.
6.  스택에 남아있는 숫자들을 조합하여 최종 결과를 반환합니다.

**예시: `number = "4177252841"`, `k = 4`**

| 현재 숫자 | 스택 상태                | k | 설명                                                       |
|:------|:---------------------|:--|:---------------------------------------------------------|
| **4** | `[4]`                | 4 | 스택이 비어있으므로 '4'를 push.                                    |
| **1** | `[4, 1]`             | 4 | 스택의 top('4')이 '1'보다 크므로 '1'을 push.                       |
| **7** | `[7]`                | 2 | '7' \> '1' (pop, k=3), '7' \> '4' (pop, k=2). '7'을 push. |
| **7** | `[7, 7]`             | 2 | 스택의 top('7')이 '7'보다 작지 않으므로 '7'을 push.                   |
| **2** | `[7, 7, 2]`          | 2 | 스택의 top('7')이 '2'보다 크므로 '2'를 push.                       |
| **5** | `[7, 7, 5]`          | 1 | '5' \> '2' (pop, k=1). '5'를 push.                        |
| **2** | `[7, 7, 5, 2]`       | 1 | 스택의 top('5')가 '2'보다 크므로 '2'를 push.                       |
| **8** | `[7, 7, 5, 8]`       | 0 | '8' \> '2' (pop, k=0). k가 0이므로 더 이상 pop 불가. '8' push.    |
| **4** | `[7, 7, 5, 8, 4]`    | 0 | '4'를 push.                                               |
| **1** | `[7, 7, 5, 8, 4, 1]` | 0 | '1'을 push.                                               |

**최종 결과:** `775841`

-----

### 4\. Java 코드 구현

Java에서는 `Stack` 클래스보다 `StringBuilder` 또는 `char[]`를 스택처럼 활용하는 것이 성능상 더 효율적입니다.

```java
class Solution {
    public String solution(String number, int k) {
        StringBuilder answerBuilder = new StringBuilder();
        int len = number.length();
        
        // 만들어야 할 숫자의 길이 = 원래 길이 - 제거할 개수
        int resultLen = len - k;

        for (char c : number.toCharArray()) {
            // 1. 스택이 비어있지 않고, 제거 횟수가 남았으며,
            // 2. 스택의 마지막 숫자가 현재 숫자보다 작으면 pop
            while (answerBuilder.length() > 0 && k > 0 && answerBuilder.charAt(answerBuilder.length() - 1) < c) {
                answerBuilder.deleteCharAt(answerBuilder.length() - 1);
                k--;
            }
            // 3. 현재 숫자를 스택에 push
            answerBuilder.append(c);
        }
        
        // 4. 만약 k가 남아있다면(예: "987"), 뒤에서부터 제거
        // 최종 결과 길이에 맞게 잘라냄
        return answerBuilder.substring(0, resultLen);
    }
}
```

-----

### 5\. 시간 복잡도 및 공간 복잡도 분석

  * **시간 복잡도: $O(N)$**

      * `N`은 `number`의 길이입니다.
      * `number`의 각 자릿수는 스택에 최대 한 번 push되고, 최대 한 번 pop됩니다. 따라서 전체 연산은 `number`의 길이에 비례하므로 선형 시간을 가집니다.

  * **공간 복잡도: $O(N)$**

      * 스택(여기서는 `StringBuilder`)에 최대 `N`개의 숫자가 저장될 수 있으므로, `N`에 비례하는 공간이 필요합니다.

-----

### 6\. 추가적으로 연관된 내용 및 꼬리질문

#### Q1: 이 그리디 전략이 항상 정답을 보장하는 이유는 무엇인가요?

가장 큰 수를 만들기 위해서는 앞자리에 최대한 큰 수가 와야 합니다. 이 알고리즘은 각 자릿수를 결정할 때, 이전에 선택된 숫자보다 더 큰 숫자가 나타나면 기존의 작은 숫자를 제거할 기회를 줍니다. 이는 매 단계에서 사전적으로(lexicographically) 가장 큰 수를 만드는 선택이며, 이러한 지역적인 최적의 선택이 모여 전역적으로도 최적의 해를 구성하게 됩니다.

#### Q2: 만약 가장 '작은' 수를 만들어야 한다면 어떻게 해야 할까요?

알고리즘의 부등호 방향만 반대로 바꾸면 됩니다. 즉, 스택의 마지막 숫자가 현재 숫자보다 **클 경우**에 pop을 수행하면 됩니다.
`while (... && answerBuilder.charAt(answerBuilder.length() - 1) > c)`

#### Q3: `k`가 남는 경우는 어떤 경우이며, 왜 뒤에서부터 잘라내야 하나요?

`k`가 남는 경우는 `number`가 "98765"처럼 내림차순으로 정렬된 형태일 때 발생합니다. 이 경우, `while`문의 pop 조건이 한 번도 참이 되지 않아 아무 숫자도 제거되지 않습니다. 이렇게 만들어진 숫자는 이미 가장 큰 순서로 배열된 것이므로, 가장 작은 수, 즉 가장 가치가 낮은 뒷부분의 숫자들을 `k`개만큼 제거하는 것이 최선의 선택입니다.