### 문제

https://school.programmers.co.kr/learn/courses/30/lessons/43238

### 1\. 문제 분석 및 핵심 아이디어

이 문제의 목표는 `n`명의 사람이 모두 심사를 마치는 데 걸리는 **최소 시간**을 찾는 것입니다.

만약 우리가 "가장 빨리 비는 심사대로 사람을 보낸다"는 단순한 그리디(Greedy) 방식으로 접근하면, 입출력 예시에서 보듯이 최적의 해를 구하지 못할 수 있습니다. 6번째 사람이 20분에 끝나는 심사대(10분 소요)에 바로 가지 않고, 1분을 기다려 21분에 비는 심사대(7분 소요)로 가는 것이 전체 시간을 28분으로 단축시키는 최적의 선택이기 때문입니다.

이처럼 어떤 선택이 미래에 더 좋은 결과를 가져올지 예측하기 어렵기 때문에, 문제의 관점을 바꿔야 합니다.

> **"최소 시간을 어떻게 찾을까?"** 에서 **"만약 총 `x`분의 시간이 주어진다면, 모든 사람(`n`명)을 심사할 수 있을까?"** 로 질문을 바꿔보는 것입니다.

`x`분 동안 각 심사관(`times[i]`)이 처리할 수 있는 사람의 수는 `x / times[i]` 명입니다. 따라서 모든 심사관이 `x`분 동안 처리할 수 있는 총 사람의 수는 `sum(x / times[i])`가 됩니다.

만약 이 총합이 `n`보다 크거나 같다면, `x`분은 모든 사람을 심사하기에 충분한 시간이라는 의미입니다. 만약 `n`보다 작다면, `x`분은 부족한 시간입니다.

이처럼 특정 시간(`x`)이 정답이 될 수 있는지 없는지를 판별할 수 있고, 시간이 길어질수록 처리 가능한 사람의 수가 단조롭게 증가하므로, 이분 탐색을 적용하여 최적의 시간 `x`를 효율적으로 찾을 수 있습니다.

- 예시: n=6, times=[7, 10]일때, 상한선은 (가장 빠르게 처리하는 심사관이 걸리는 시간)7 * n(6) = 42. 하한선은 최소 한명을 심사하는데 걸리는 시간은 1분. 이걸 놓고 이분탐색.

-----

### 2\. 이분 탐색 (Binary Search) 설계

이분 탐색을 적용하기 위해 탐색할 시간의 범위를 설정해야 합니다.

  * **탐색 범위의 시작 (left): 1**
      * 최소 시간은 1분부터 시작할 수 있습니다.
  * **탐색 범위의 끝 (right): `n * max(times)`**
      * 가장 비효율적인 경우는, 가장 오래 걸리는 심사대에서 모든 사람을 처리하는 것입니다. 이 시간은 우리가 구하려는 최적의 시간보다 반드시 크거나 같으므로 안전한 상한선이 됩니다.
      * `n`과 `times`의 최댓값이 10억이므로, 두 값을 곱하면 `long` 타입의 범위를 벗어날 수 있습니다. 따라서 `long` 타입으로 계산해야 합니다.

이제 이 범위 내에서 다음과 같은 과정으로 최적의 시간을 찾습니다.

1.  `left`와 `right`의 중간값 `mid`를 현재 검사할 시간으로 설정합니다.
2.  `mid` 시간 동안 모든 심사관이 심사할 수 있는 총 사람의 수를 계산합니다. (`sum = Σ(mid / times[i])`)
3.  계산된 사람의 수(`sum`)와 기다리는 사람의 수(`n`)를 비교합니다.
      * **`sum >= n` 인 경우:** `mid` 시간은 모든 사람을 심사하기에 충분하거나 더 넉넉한 시간입니다. 즉, `mid`는 정답 후보가 될 수 있습니다. 더 짧은 시간도 가능한지 확인하기 위해 정답을 `mid`로 갱신하고, 탐색 범위를 `[left, mid - 1]`로 줄여 더 작은 시간을 탐색합니다.
      * **`sum < n` 인 경우:** `mid` 시간은 모든 사람을 심사하기에 부족한 시간입니다. 더 많은 시간이 필요하므로 탐색 범위를 `[mid + 1, right]`로 옮겨 더 긴 시간을 탐색합니다.
4.  `left`가 `right`보다 커질 때까지 이 과정을 반복하면, 마지막으로 갱신된 정답이 최소 시간이 됩니다.

-----

### 3\. Java 코드 구현

```java
import java.util.Arrays;

class Solution {
    public long solution(int n, int[] times) {
        // 이분 탐색을 위해 심사 시간 배열을 정렬합니다.
        // 정렬하지 않아도 기능상 문제는 없지만, right의 상한선을 더 타이트하게 잡는 최적화가 가능합니다.
        // 여기서는 가장 보편적인 풀이를 위해 정렬을 포함합니다.
        Arrays.sort(times);
        
        long left = 1;
        // 최악의 경우: 가장 오래 걸리는 심사관에게 모든 사람이 심사받는 경우
        // n과 times의 원소는 int 범위지만, 곱셈 결과는 long 범위를 초과할 수 있으므로 형변환에 주의해야 합니다.
        long right = (long) n * times[times.length - 1]; 
        
        long answer = right; // 정답을 최댓값으로 초기화

        while (left <= right) {
            long mid = left + (right - left) / 2; // '(left + right) / 2' 를 쓰지 않음. 숫자가 너무 크기때문에 오버플로우 방지
            long sum = 0; // mid 시간 동안 심사할 수 있는 총 사람의 수

            // 각 심사관이 mid 시간 동안 몇 명을 처리할 수 있는지 계산하여 합산
            for (int time : times) {
                sum += mid / time;
                // sum이 n을 초과하면 더 이상 계산할 필요가 없으므로 루프를 중단하여 최적화
                if (sum >= n) {
                    break;
                }
            }

            if (sum >= n) {
                // mid 시간으로 충분하거나 시간이 남는 경우
                // 더 짧은 시간을 찾아보기 위해 범위를 줄임
                answer = mid;
                right = mid - 1;
            } else {
                // mid 시간으로 부족한 경우
                // 더 긴 시간이 필요하므로 범위를 늘림
                left = mid + 1;
            }
        }
        
        return answer;
    }
}
```

-----

### 4\. 시간 복잡도 및 공간 복잡도 분석

  * **시간 복잡도: $O(M \cdot \log(N \cdot \text{max\_time}))$**

      * `M`은 심사관의 수 (`times` 배열의 길이), `N`은 사람의 수입니다.
      * 이분 탐색의 탐색 범위는 약 `N * max_time` 이므로, 탐색 횟수는 $\log(N \cdot \text{max\_time})$에 비례합니다.
      * 이분 탐색의 각 단계마다 `times` 배열을 순회하며(`M`번) 처리 가능한 사람 수를 계산합니다.
      * 따라서 최종 시간 복잡도는 위와 같이 결정됩니다. `Arrays.sort()`의 시간 복잡도 $O(M \log M)$이 있지만, 일반적으로 $M$이 $N$보다 훨씬 작으므로 이분 탐색 부분이 전체 복잡도를 지배합니다.

  * **공간 복잡도: $O(1)$**

      * `left`, `right`, `mid`, `sum` 등 몇 개의 변수만 추가로 사용하므로, 입력 크기와 무관하게 일정한 공간만 사용합니다.

-----

### 5\. 추가적으로 연관된 내용 및 꼬리질문

#### Q1: 왜 이 문제에서 그리디 알고리즘(예: 우선순위 큐)으로 풀면 정답을 찾을 수 없나요?

그리디 알고리즘은 '현재 시점에서 가장 최적인 선택'을 하는 방식입니다. 이 문제에 적용하면 '현재 비어있는 심사대 중 가장 빨리 끝나는 곳'으로 사람을 배정하는 전략이 됩니다. 하지만 입출력 예시처럼, 당장 비어있는 심사대(10분 소요)보다 **조금 기다렸다가 더 빠른 심사대(7분 소요)로 가는 것**이 전체 완료 시간을 단축시킬 수 있습니다. 즉, 현재의 최적 선택이 전체의 최적을 보장하지 않기 때문에 그리디 방식으로는 해결할 수 없습니다.

#### Q2: 탐색 범위의 최댓값을 `n * max(times)`로 설정하는 이유는 무엇인가요? 더 최적화할 수 있나요?

`n * max(times)`는 '가장 느린 심사관이 모든 사람을 처리하는 시간'으로, 정답이 될 수 있는 시간 중 가장 큰 값, 즉 \*\*안전한 상한선(upper bound)\*\*입니다. 실제 정답은 이 값보다 절대 클 수 없으므로 이분 탐색의 `right` 값으로 적절합니다. 이론적으로는 `n * min(times)`도 상한선이 될 수 있지만(모든 사람이 가장 빠른 심사관보다 빠른 다른 심사관에게 갈 이유가 없으므로), `max(times)`를 사용하는 것이 더 직관적이고 안전한 상한선을 제공합니다.

#### Q3: 이분 탐색은 주로 어떤 종류의 문제에 효과적인가요?

이분 탐색은 \*\*결정 문제(Decision Problem)\*\*를 \*\*최적화 문제(Optimization Problem)\*\*로 바꾸어 풀 때 매우 효과적입니다. 이 문제처럼 '최솟값을 찾아라' 같은 최적화 문제를 '어떤 값 `x`가 답이 될 수 있는가?'라는 예/아니오로 답할 수 있는 결정 문제로 바꿀 수 있고, 그 결정의 결과가 입력 값 `x`에 대해 단조성(monotonicity)을 가질 때 (즉, x가 커지면 결과도 참으로 유지되거나 거짓으로 유지될 때) 이분 탐색을 강력한 도구로 사용할 수 있습니다. 이러한 기법을 \*\*파라메트릭 서치(Parametric Search)\*\*라고도 합니다.